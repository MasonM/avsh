#!/usr/bin/env ruby

#### START CONFIGURATION #####
optional_config_file_path = File.absolute_path('~/.avsh_config')
if File.exist?(optional_config_file_path)
	load(optional_config_file_path)
else
	# Name of the Vagrant VM in which to execute commands. Defaults to 'dev'.
	AVSH_VM_NAME = ENV.fetch('AVSH_VM_NAME', 'dev')

	# Directory containing the Vagrantfile for the above VM. Defaults to current directory.
	AVSH_VAGRANTFILE_DIR = ENV.fetch("AVSH_VAGRANTFILE_DIR", Dir.pwd)
end
#### END CONFIGURATION #####

require 'open3'

# Enable debug output by prepending AVSH_DEBUG=1 to the command (e.g. 'AVSH_DEBUG=1 avsh ls')
def debug(msg)
	puts "#{caller[0]}: #{msg}" if ENV.include?('AVSH_DEBUG')
end

class HostToGuestDirectoryTranslator
	# Translates a directory on the host to the corresponding directory in the guest by matching
	# against the synced_folder declarations extracted from the Vagrantfile

	def initialize(config)
		@config = config
	end

	def translate(host_directory)
		# Iterates over the synced_folders dictionary to see if the given directory
		# is a descendent of (or equal to) one of the src folders.
		vagrantfile_path = find_vagrantfile

		real_host_directory = File.realpath(host_directory)
		if real_host_directory == @config.vagrantfile_dir
			debug "Current directory is the Vagrantfile directory (#{@config.vagrantfile_dir}), so use '/vagrant'"
			return '/vagrant'
		end

		synced_folders = DummyVagrantEnvironment.find_synced_folders(vagrantfile_path, @config.vm_name)
		synced_folders.each do |src, dest|
			real_src = File.realpath(src, @config.vagrantfile_dir)
			if real_host_directory.start_with?(real_src)
				relative_directory = real_host_directory[real_src.length .. -1]
				full_directory = File.join(dest, relative_directory)
				debug "Guest path for '#{real_host_directory}' is '#{full_directory}'"
				return full_directory
			end
		end

		debug "Couldn't find guest directory for '#{real_host_directory}', falling back to /vagrant"
		return '/vagrant'
	end

	private

	def find_vagrantfile
		# Vagrant allows the Vagrantfile to be stored as "vagrantfile", so we have to check for both.
		for filename in ['Vagrantfile', 'vagrantfile']
			path = File.join(@config.vagrantfile_dir, filename)
			return path if File.readable? path
		end
		STDERR.puts(
			"avsh couldn't find the Vagrantfile for the directory #{@config.vagrantfile_dir}\n" +
			"This usually means you need to specify the AVSH_VAGRANTFILE_DIR configuration option. " +
			"See README.md for details."
		)
		exit 1
	end
end

module DummyVagrantEnvironment
	# This module is a horrible hack to parse out the synced_folder declarations from a Vagrantfile,
	# without incurring the overhead of loading Vagrant. It uses a binding object to eval the
	# Vagrantfile in this module, which will communicate with the dummy Vagrant module below.

	def self.find_synced_folders(vagrantfile_path, vm_name)
		debug "Parsing synced folders from #{vagrantfile_path}..."

		# The dummy_configure object will be used to collect the synced_folder declarations. We need to
		# set it as a class variable on Vagrant, since we can't tell the Vagrantfile to use a specific
		# instance of Vagrant.
		dummy_configure = Configure.new(vm_name)
		Vagrant.class_variable_set(:@@configure, dummy_configure)

		# Eval the Vagrantfile with this module as the execution context
		begin
			binding.eval(File.read(vagrantfile_path), vagrantfile_path)
		rescue Exception => e
			STDERR.puts("avsh got an unexpected error while reading the Vagrantfile at #{vagrantfile_path}:\n#{e.inspect}")
			exit 1
		end

		debug "Got synced folders: #{dummy_configure.synced_folders}"
		dummy_configure.synced_folders
	end

	module Vagrant
		# Dummy Vagrant module that stubs out everything except what's needed to extract config details.

		def self.has_plugin?(*args)
			# Just lie and say we have the plugin, because a Vagrantfile that calls this is probably doing
			# dependency checking, and will terminate if this doesn't return true. However, this could
			# result in unwanted behavior if the Vagrantfile does weird things like ensuring a plugin
			# DOESN'T exist. I've never seen that before, though.
			true
		end

		def self.configure(api_version)
			# Give the provided block the dummy_configure object set above in DummyVagrantEnvironment.find_synced_folders
			yield @@configure
		end

		def self.method_missing(*args) end # ignore everything else
	end

	class Configure
		attr_reader :synced_folders

		def initialize(vm_name)
			@vm_name = vm_name
			@synced_folders = {}
		end

		def synced_folder(src, dest, *args)
			@synced_folders[src] = dest unless @synced_folders.include?(src)
		end

		def define(vm_name, *args)
			if vm_name == @vm_name
				yield self
			else
				# The guest machine is different than the VM we care about, so give it a new Configure
				# object that'll be thrown away at the end.
				yield Configure.new(nil)
			end
		end

		def method_missing(methodId, *args)
			# Ensure this object continues to be used when defining a multi-machine setup, and ignore any
			# other methods, since they don't matter.
			yield self if block_given?
			self
		end
	end
end

class SshCommandExecutor
	def initialize(config)
		@config = config
	end

	def execute(guest_directory, command)
		if not File.socket?(ssh_controlmaster_path)
			initialize_master_socket
		end

		ssh_command = ["ssh", "-o ControlPath #{ssh_controlmaster_path}"]
		if command.empty?
			# No command, so run a login shell
			command = 'exec $SHELL -l'
			ssh_command.push('-t') # force TTY allocation
		end
		ssh_command.push(@config.vm_name, "cd #{guest_directory}; #{command}")

		debug "Executing '#{ssh_command}'"

		# Script execution ends here, since SSH will replace the current process.
		exec(*ssh_command)

		# Shouldn't be possible to get to this point, but check anyway
		STDERR.puts("avsh failed to pass control to SSH. Please file a bug at https://github.com/MasonM/avsh/issues")
		exit 1
	end

	private

	def ssh_controlmaster_path
		# Put the socket file in /tmp/, since that seems like the most portable option that doesn't
		# require any extra work from the user. This means the socket file will be lost on reboot, but
		# that just means there will be a minor delay as it re-establishes the socket the next time avsh
		# is run.
		#
		# Another option would be to use AVSH_VAGRANTFILE_DIR/.vagrant/, which is what vassh does, but Vagrant
		# manages that directory and I don't think it's safe to be storing foreign files there.
		"/tmp/avsh_#{@config.vm_name}_controlmaster.sock"
	end

	def read_vagrant_ssh_config
		# Runs "vagrant ssh-config" to get the SSH config, which is needed so we can establish a control
		# socket using SSH directly.
		#
		# The VAGRANT_CWD environment variable tells Vagrant to look for the Vagrantfile in that
		# directory. See https://www.vagrantup.com/docs/other/environmental-variables.html
		ssh_config_command = ["vagrant", "ssh-config", @config.vm_name]
		debug "Executing vagrant ssh-config command: #{ssh_config_command}"
		stdout, stderr, status = Open3.capture3({"VAGRANT_CWD" => @config.vagrantfile_dir}, *ssh_config_command)
		if not status.success? or not stderr.empty?
			human_readable_command = "VAGRANT_CWD=#{@config.vagrantfile_dir} #{ssh_config_command.join(' ')}"
			if not status.success?
				STDERR.puts(
					"avsh failed to determine the SSH configuration for the VM '#{@config.vm_name}'.\n"+
					"Is the AVSH_VAGRANTFILE_DIR setting correct? See README.md for details.\n\n" +
					"Details:\n" +
					"Command \"#{human_readable_command}\" exited with status #{status.exitstatus}\n" +
					"Vagrant output:\n#{stdout}#{stderr}"
				)
			else
				STDERR.puts("avsh got an unexpected error message from Vagrant while running \"#{human_readable_command}\": #{stderr}")
			end
			exit 1
		end
		debug "Got SSH config for #{@config.vm_name}: stdout"
		stdout
	end

	def initialize_master_socket
		debug "Establishing control socket for '#{@config.vm_name}' at '#{ssh_controlmaster_path}'"

		ssh_config = read_vagrant_ssh_config()
		# This is mostly based off
		# https://en.wikibooks.org/wiki/OpenSSH/Cookbook/Multiplexing#Manually_Establishing_Multiplexed_Connections
		ssh_cmd = [
			"ssh",
			# Force TTY allocation
			"-t", "-t",
			# Don't execute a command, just go in background immediately
			"-f", "-N",
			# Read the SSH config from stdin. Note that /dev/stdin isn't in the POSIX standard, but I
			# don't know of any modern Unix that doesn't have it.
			"-F/dev/stdin",
			# Persist socket indefinitely
			"-o ControlPersist yes",
			# Auto-connect
			"-o ControlMaster auto",
			# Path to control socket
			"-o ControlPath #{ssh_controlmaster_path}",
			# Hostname set in ssh_config
			"#{@config.vm_name}"
		]
		debug "Executing SSH command '#{ssh_cmd}'"
		Open3.popen3(*ssh_cmd) do |stdin, stdout, stderr, wait_threads|
			if stdin.closed?
				STDERR.puts("avsh failed to establish a SSH ControlMaster socket. Error from SSH: '#{stderr.read}'")
				exit 1
			end
			stdin.puts(ssh_config)
		end
	end
end

config = Struct.new(:vm_name, :vagrantfile_dir).new(AVSH_VM_NAME, AVSH_VAGRANTFILE_DIR)
guest_dir = HostToGuestDirectoryTranslator.new(config).translate(Dir.pwd)
SshCommandExecutor.new(config).execute(guest_dir, ARGV.join(' '))
